const { htmlTemplate, MockatonLogo } = await import(`./_htmlTemplate.js?${Date.now()}`)
const { shell, raw } = await import(`./_syntaxHighlight.js?${Date.now()}`)

// language=html
export default () => htmlTemplate({
	head: `
		<title>Mockaton</title>
		<link rel="stylesheet" href="/index.css" />
	`,
	body: `
		<h1>${MockatonLogo()}</h1>
		<p>
			HTTP mock server for simulating APIs
			â€” ideal for triggering difficult to reproduce backend states.
		</p>

		<h2>Convention</h2>
		<p>
			With Mockaton thereâ€™s no need to write code for wiring up your mocks.
			Instead, a given directory is scanned for filenames following a
			convention similar to the URLs. For example, for <span
			class="NullLink">/api/company/123</span>, the filename could be:
		</p>

		${raw(`
my-mocks-dir<strong>/api/company/[id]</strong>.GET.200.json
`)}


		<h2>Dashboard</h2>
		<div class="RegionImg" data-max-width="761">
			<picture>
				<source media="(prefers-color-scheme: light)" srcset="/assets/media/pic-for-readme.vp762x762.light.gold.avif">
				<source media="(prefers-color-scheme: dark)" srcset="/assets/media/pic-for-readme.vp762x762.dark.gold.avif">
				<img alt="Mockaton Dashboard" src="/assets/media/pic-for-readme.vp762x762.light.gold.avif">
			</picture>
		</div>

		<h3>Dashboard Features</h3>
		<ul>
			<li>Delay responses ðŸ•“</li>
			<li>
				Cycle an autogenerated <code>500</code> error
				(e.g., for testing retries)
			</li>
			<li>Select a mock variant for a particular route</li>
			<li>
				<strong>Bulk Select</strong> mocks
				to simulate the complete states you need
				<div class="RegionImg" data-max-width="200">
					<img src="/assets/media/bulk-select.avif" alt="">
				</div>
			</li>
		</ul>
		<p>
			On the other hand, thereâ€™s a <a href="/api">Programmatic
			HTTP API</a>, which is useful for setting up automated tests.
		</p>

		<h2>Multiple Mock Variants</h2>
		<p>
			Each route can have multiple mock files. You can do that 
			by adding comments in parentheses to the filename:
		</p>
		<pre>
api/user<strong>(at step 1.0)</strong>.GET.200.json
api/user<strong>(at step 1.1)</strong>.GET.200.json
</pre>

		<p>
			Or, based on the response status code. Comments are optional in these cases:
		</p>
		<pre>
api/login(invalid attempt).POST.<strong>401</strong>.json
api/login(locked out user).POST.<strong>423</strong>.json
</pre>


		</body>
		</html>
	`
})


// 	<p>Or by using different status codes.</p>
// ${raw(`
// api/videos.GET.<strong>204</strong>.empty <span class="syntax_comment"># No Content</span>
// api/videos.GET.<strong>403</strong>.json  <span class="syntax_comment"># Forbidden</span>
// api/videos.GET.<strong>500</strong>.json  <span class="syntax_comment"># Internal Server Error</span>
// `)}
//
