import { htmlTemplate, MockatonLogo } from './htmlTemplate.js'
import { js, shell, raw } from './_syntaxHighlight.js'

// language=html
export default () => htmlTemplate({
	head: `
		<title>Mockaton</title>
		<link rel="stylesheet" href="/index.css" />
	`,
	body: `
		<h1>${MockatonLogo()}</h1>
		<p>
			HTTP mock server for simulating APIs
			â€” ideal for triggering difficult to reproduce backend states.
		</p>
		
		<h2>Overview</h2>
		<p>
			A given directory is scanned for filenames following a
			convention similar to the URLs. For example, for <span
			class="NullLink">/api/company/123</span>, the filename could be:
		</p>
		
		${raw(`
my-mocks-dir<strong>/api/company/[id]</strong>.GET.200.json
`)}


		<h2>Quick Start (Docker)</h2>
		<p>
			This will spin up Mockaton with the sample directories
			included in the repository mounted on the container.
		</p>

		${shell`
git clone https://github.com/ericfortis/mockaton.git --depth 1
cd mockaton
make docker
`}


		<h2>Dashboard</h2>
		<div class="RegionImg" data-max-width="761">
			<picture>
				<source media="(prefers-color-scheme: light)" srcset="/assets/media/pic-for-readme.vp762x762.light.gold.avif">
				<source media="(prefers-color-scheme: dark)" srcset="/assets/media/pic-for-readme.vp762x762.dark.gold.avif">
				<img alt="Mockaton Dashboard" src="/assets/media/pic-for-readme.vp762x762.light.gold.avif">
			</picture>
		</div>

		<h3>Dashboard Features</h3>
		<ul>
			<li>Delay responses ðŸ•“</li>
			<li>
				Cycle an autogenerated <code>500</code> error
				(e.g., for testing retries)
			</li>
			<li>Select a mock variant for a particular route</li>
			<li>
				<strong>Bulk Select</strong> mocks
				to simulate the complete states you need
				<div class="RegionImg" data-max-width="200">
					<img src="/assets/media/bulk-select.avif" alt="">
				</div>
			</li>
		</ul>
		<p>
			On the other hand, thereâ€™s a <a href="/api">Programmatic
			HTTP API</a>, which is useful for setting up automated tests.
		</p>

		<h2>Multiple Mock Variants</h2>
		<p>
			Each route can have multiple mock files. You can do that
			by adding comments in parentheses to the filename:
		</p>
		<pre>
api/user<strong>(at step 1.0)</strong>.GET.200.json
api/user<strong>(at step 1.1)</strong>.GET.200.json
</pre>

		<p>
			Or, based on the response status code. Comments are optional in these cases:
		</p>
		<pre>
api/login(invalid attempt).POST.<strong>401</strong>.json
api/login(locked out user).POST.<strong>423</strong>.json
</pre>


		<h2>
			You can write JSON mocks in JavaScript or TypeScript
		</h2>
		<p>
			An Object, Array, or String is sent as JSON
		</p>

		<p><code>api/foo.GET.200.js</code></p>
		${js`
export default { foo: 'bar' }
`}
		<p>
			If you need more control, you can use <a href="/functional-mocks">Functional Mocks</a>,
			which are HTTP handlers, so you can handle any complex logic, URL parsing, saving to 
			a database, etc.
		</p>

		</body>
		</html>
	`
})


// 	<p>Or by using different status codes.</p>
// ${raw(`
// api/videos.GET.<strong>204</strong>.empty <span class="syntax_comment"># No Content</span>
// api/videos.GET.<strong>403</strong>.json  <span class="syntax_comment"># Forbidden</span>
// api/videos.GET.<strong>500</strong>.json  <span class="syntax_comment"># Internal Server Error</span>
// `)}
//
