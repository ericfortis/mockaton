{
	"openapi": "3.1.2",
	"info": {
		"title": "Mockaton Control API",
		"version": "1.0.0"
	},
	"servers": [
		{
			"url": "http://localhost:2020"
		}
	],
	"paths": {
		"/mockaton/reset": {
			"patch": {
				"summary": "Re-initialize Mockaton",
				"description": "The selected mocks, cookies, and delays go back to default, but `proxyFallback`, `collectProxied`, and `corsAllowed` are not affected.",
				"x-js-client-example": "await mockaton.reset()",
				"responses": {
					"200": {
						"description": "OK"
					}
				}
			}
		},
		"/mockaton/bulk-select-by-comment": {
			"patch": {
				"summary": "Select all mocks that have a particular comment",
				"x-js-client-example": "await mockaton.bulkSelectByComment('(demo-a)')",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "string",
								"description": "Parentheses are optional, so you can pass a partial match. For example, passing `'demo-'` (without the final `a`) works too. On routes with many partial matches, their first mock in alphabetical order wins.",
								"example": "(demo-a)"
							}
						}
					}
				},
				"responses": {
					"200": {
						"$ref": "#/components/responses/Broker"
					}
				}
			}
		},
		"/mockaton/select": {
			"patch": {
				"summary": "Select a mock file for a route",
				"x-js-client-example": "await mockaton.select('api/user/avatar.GET.json')",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"$ref": "#/components/schemas/Filename"
							}
						}
					}
				},
				"responses": {
					"200": {
						"$ref": "#/components/responses/Broker"
					},
					"422": {
						"description": "Mock file doesn’t exist",
						"content": {
							"application/json": {
								"schema": {
									"type": "string"
								},
								"example": "Mock file does not exist"
							}
						}
					}
				}
			}
		},
		"/mockaton/toggle500": {
			"patch": {
				"summary": "Toggle 500 for a route",
				"description": "Selects the first found 500, which could be the autogenerated one. Or, selects the default file.",
				"x-js-client-example": "await mockaton.toggle500('GET', '/api/user/friends')",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "array",
								"minItems": 2,
								"maxItems": 2,
								"prefixItems": [
									{
										"$ref": "#/components/schemas/Method"
									},
									{
										"$ref": "#/components/schemas/UrlMask"
									}
								],
								"additionalItems": false
							},
							"example": [
								"GET",
								"/api/user"
							]
						}
					}
				},
				"responses": {
					"200": {
						"$ref": "#/components/responses/Broker"
					},
					"422": {
						"description": "Route does not exist"
					}
				}
			}
		},
		"/mockaton/proxied": {
			"patch": {
				"summary": "Set whether a route is proxied",
				"description": "Applicable only when there’s a proxy fallback server URL already set. See `PATCH /mockaton/fallback`",
				"x-js-client-example": "await mockaton.setRouteIsProxied('GET', '/api/user/friends', true)",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "array",
								"minItems": 3,
								"maxItems": 3,
								"prefixItems": [
									{
										"$ref": "#/components/schemas/Method"
									},
									{
										"$ref": "#/components/schemas/UrlMask"
									},
									{
										"type": "boolean",
										"description": "proxied",
										"example": true
									}
								],
								"additionalItems": false
							},
							"example": [
								"GET",
								"/api/user",
								true
							]
						}
					}
				},
				"responses": {
					"200": {
						"$ref": "#/components/responses/Broker"
					},
					"422": {
						"description": "Invalid request. Possible reasons:\n- Route does not exist\n- Expected boolean for `proxied`\n- No `proxyFallback` configured\n"
					}
				}
			}
		},
		"/mockaton/delay": {
			"patch": {
				"summary": "Set whether a route is delayed",
				"x-js-client-example": "await mockaton.setRouteIsDelayed('GET', '/api/user/friends', true)",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "array",
								"minItems": 3,
								"maxItems": 3,
								"prefixItems": [
									{
										"$ref": "#/components/schemas/Method"
									},
									{
										"$ref": "#/components/schemas/UrlMask"
									},
									{
										"type": "boolean",
										"description": "delayed",
										"example": true
									}
								],
								"additionalItems": false
							},
							"example": [
								"GET",
								"/api/user",
								true
							]
						}
					}
				},
				"responses": {
					"200": {
						"$ref": "#/components/responses/Broker"
					},
					"422": {
						"description": "Invalid request. Possible reasons:\n- Route does not exist\n- Expected boolean for `delayed`\n"
					}
				}
			}
		},
		"/mockaton/static-status": {
			"patch": {
				"summary": "Set static HTTP status for a route",
				"x-js-client-example": "await mockaton.setStaticRouteStatus('/media/picture.png', 404)",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "array",
								"minItems": 2,
								"maxItems": 2,
								"prefixItems": [
									{
										"$ref": "#/components/schemas/UrlStatic"
									},
									{
										"type": "integer",
										"enum": [
											200,
											404
										],
										"example": 404
									}
								],
								"additionalItems": false
							},
							"example": [
								"/media/picture.png",
								404
							]
						}
					}
				},
				"responses": {
					"200": {
						"description": "OK"
					},
					"422": {
						"description": "Invalid request. Possible reasons:\n- Static route does not exist\n- Expected 200 or 404 `status`\n"
					}
				}
			}
		},
		"/mockaton/delay-static": {
			"patch": {
				"summary": "Set static delay flag for a route",
				"x-js-client-example": "await mockaton.setStaticRouteIsDelayed('/media/picture.png', true)",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "array",
								"minItems": 2,
								"maxItems": 2,
								"prefixItems": [
									{
										"$ref": "#/components/schemas/UrlStatic"
									},
									{
										"type": "boolean",
										"description": "delayed",
										"example": true
									}
								],
								"additionalItems": false
							},
							"example": [
								"/media/picture.png",
								true
							]
						}
					}
				},
				"responses": {
					"200": {
						"description": "OK"
					},
					"422": {
						"description": "Invalid request. Possible reasons:\n- Static route does not exist\n- Expected boolean for `delayed`\n"
					}
				}
			}
		},
		"/mockaton/global-delay": {
			"patch": {
				"summary": "Set global delay for all responses",
				"x-js-client-example": "await mockaton.setGlobalDelay(1500)",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "integer",
								"description": "Delay in milliseconds",
								"example": 1500
							}
						}
					}
				},
				"responses": {
					"200": {
						"description": "OK"
					},
					"422": {
						"description": "Expected non-negative integer"
					}
				}
			}
		},
		"/mockaton/cors": {
			"patch": {
				"summary": "Enable or disable CORS",
				"x-js-client-example": "await mockaton.setCorsAllowed(false)",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "boolean",
								"description": "Is enabled?"
							}
						}
					}
				},
				"responses": {
					"200": {
						"description": "OK"
					},
					"422": {
						"description": "Expected boolean"
					}
				}
			}
		},
		"/mockaton/fallback": {
			"patch": {
				"summary": "Set proxy fallback address",
				"x-js-client-example": "await mockaton.setProxyFallback('http://example.com')",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "string",
								"description": "URL",
								"example": "https://example.com"
							}
						}
					}
				},
				"responses": {
					"200": {
						"description": "OK"
					},
					"422": {
						"description": "Invalid Proxy Fallback URL"
					}
				}
			}
		},
		"/mockaton/collect-proxied": {
			"patch": {
				"summary": "Enable or disable collection of proxied responses",
				"description": "Applicable only when there’s a proxy fallback server URL already set. See `PATCH /mockaton/fallback`",
				"x-js-client-example": "await mockaton.setCollectProxied(true)",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "boolean",
								"description": "Should Collect?",
								"example": true
							}
						}
					}
				},
				"responses": {
					"200": {
						"description": "OK"
					},
					"422": {
						"description": "Expected boolean"
					}
				}
			}
		},
		"/mockaton/cookies": {
			"patch": {
				"summary": "Select a cookie label",
				"x-js-client-example": "await mockaton.selectCookie('Normal User')",
				"requestBody": {
					"required": true,
					"content": {
						"application/json": {
							"schema": {
								"type": "string",
								"description": "Cookie key",
								"example": "Normal User"
							}
						}
					}
				},
				"responses": {
					"200": {
						"description": "Available cookie labels",
						"content": {
							"application/json": {
								"schema": {
									"$ref": "#/components/schemas/CookieSelectionList"
								}
							}
						}
					},
					"422": {
						"description": "Cookie key not found"
					}
				}
			}
		},
		"/mockaton/state": {
			"get": {
				"summary": "Get complete Mockaton state",
				"x-js-client-example": "await mockaton.getState()",
				"responses": {
					"200": {
						"description": "Mockaton state",
						"content": {
							"application/json": {
								"schema": {
									"$ref": "#/components/schemas/State"
								}
							}
						}
					}
				}
			}
		},
		"/mockaton/sync-version": {
			"get": {
				"summary": "Get sync version for long‑polling updates",
				"description": "A counter that’s incremented when a new mock is added, removed, or renamed.",
				"x-js-client-example": "await mockaton.getSyncVersion()",
				"parameters": [
					{
						"name": "sync_version",
						"in": "header",
						"required": false,
						"example": -1,
						"schema": {
							"type": "number"
						},
						"description": "When not present, or when the version mismatches it responds right away. Otherwise, it long polls. Times out in 8s."
					}
				],
				"responses": {
					"200": {
						"description": "Sync version value",
						"content": {
							"application/json": {
								"schema": {
									"type": "number",
									"description": "Incremental integer"
								}
							}
						}
					}
				}
			}
		}
	},
	"components": {
		"responses": {
			"Broker": {
				"description": "Updated broker state",
				"content": {
					"application/json": {
						"schema": {
							"$ref": "#/components/schemas/ClientMockBroker"
						}
					}
				}
			}
		},
		"schemas": {
			"Method": {
				"type": "string",
				"description": "HTTP Method of the mock",
				"example": "GET"
			},
			"UrlMask": {
				"type": "string",
				"example": "/api/user/friends"
			},
			"UrlStatic": {
				"type": "string",
				"description": "Filename of a static mock",
				"example": "/media/picture.png"
			},
			"Filename": {
				"type": "string",
				"description": "Mock filename. The convention is UrlMask.Method.StatusCode.Extension",
				"example": "api/user/avatar.GET.200.svg"
			},
			"ClientMockBroker": {
				"type": "object",
				"properties": {
					"mocks": {
						"type": "array",
						"items": {
							"$ref": "#/components/schemas/Filename"
						}
					},
					"file": {
						"$ref": "#/components/schemas/Filename"
					},
					"status": {
						"type": "number"
					},
					"auto500": {
						"type": "boolean"
					},
					"delayed": {
						"type": "boolean"
					},
					"proxied": {
						"type": "boolean"
					}
				},
				"required": [
					"mocks",
					"file",
					"status",
					"auto500",
					"delayed",
					"proxied"
				]
			},
			"ClientStaticBroker": {
				"type": "object",
				"properties": {
					"route": {
						"$ref": "#/components/schemas/UrlStatic"
					},
					"delayed": {
						"type": "boolean"
					},
					"status": {
						"type": "number"
					}
				},
				"required": [
					"route",
					"delayed",
					"status"
				]
			},
			"State": {
				"type": "object",
				"properties": {
					"brokersByMethod": {
						"type": "object",
						"additionalProperties": {
							"type": "object",
							"additionalProperties": {
								"$ref": "#/components/schemas/ClientMockBroker"
							}
						}
					},
					"staticBrokers": {
						"type": "object",
						"additionalProperties": {
							"$ref": "#/components/schemas/ClientStaticBroker"
						}
					},
					"cookies": {
						"$ref": "#/components/schemas/CookieSelectionList"
					},
					"comments": {
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"delay": {
						"type": "number"
					},
					"collectProxied": {
						"type": "boolean"
					},
					"proxyFallback": {
						"type": "string"
					},
					"corsAllowed": {
						"type": "boolean"
					}
				},
				"required": [
					"brokersByMethod",
					"staticBrokers",
					"cookies",
					"comments",
					"delay",
					"collectProxied",
					"proxyFallback"
				]
			},
			"CookieSelectionList": {
				"type": "array",
				"items": {
					"type": "array",
					"minItems": 2,
					"maxItems": 2,
					"prefixItems": [
						{
							"type": "string",
							"description": "Label"
						},
						{
							"type": "boolean",
							"description": "Selected"
						}
					],
					"additionalItems": false
				}
			}
		}
	}
}
