import { AUTOGENERATED_500_COMMENT, HEADER_FOR_502 } from './ApiConstants.js'
import { parseFilename, extractComments } from './Filename.js'
import { Commander } from './ApiCommander.js'


const CSS = {
	BulkSelector: null,
	CookieSelector: null,
	DelayToggler: null,
	ErrorToast: null,
	FallbackBackend: null,
	Field: null,
	GlobalDelayField: null,
	GroupByMethod: null,
	InternalServerErrorToggler: null,
	MenuTrigger: null,
	Method: null,
	MockList: null,
	MockSelector: null,
	NotFoundToggler: null,
	PayloadViewer: null,
	PreviewLink: null,
	ProgressBar: null,
	ProxyToggler: null,
	ResetButton: null,
	Resizer: null,
	SaveProxiedCheckbox: null,
	SettingsMenu: null,

	chosen: null,
	dittoDir: null,
	empty: null,
	leftSide: null,
	nonDefault: null,
	red: null,
	rightSide: null,
	status4xx: null,

	json: null,
	syntaxAttr: null,
	syntaxAttrVal: null,
	syntaxKey: null,
	syntaxPunc: null,
	syntaxStr: null,
	syntaxTag: null,
	syntaxVal: null
}
for (const k of Object.keys(CSS))
	CSS[k] = k


const state = /** @type {State} */ {
	brokersByMethod: {},
	staticBrokers: {},
	cookies: [],
	comments: [],
	delay: 0,

	collectProxied: false,
	proxyFallback: '',
	get canProxy() {
		return Boolean(state.proxyFallback)
	},

	groupByMethod: initPreference('groupByMethod'),
	toggleGroupByMethod() {
		state.groupByMethod = !state.groupByMethod
		togglePreference('groupByMethod', state.groupByMethod)
		updateState()
	},

	leftSideWidth: undefined
}


const mockaton = new Commander(location.origin)
updateState()
deferred(initLongPoll)

async function updateState() {
	try {
		const response = await mockaton.getState()
		if (!response.ok)
			throw response.status
		Object.assign(state, await response.json())
		document.body.replaceChildren(...App())
	}
	catch (error) {
		onError(error)
	}
}

const r = createElement
const s = createSvgElement
const t = translation => translation[0]

const leftSideRef = useRef()

function App() {
	const { leftSideWidth } = state
	return [
		Header(),
		r('main', null,
			r('div', {
					ref: leftSideRef,
					style: { width: leftSideWidth + 'px' },
					className: CSS.leftSide
				},
				r('table', null,
					MockList(),
					StaticFilesList())),
			r('div', { className: CSS.rightSide },
				Resizer(),
				PayloadViewer()))
	]
}


function Header() {
	return (
		r('header', null,
			r('img', {
				alt: t`Mockaton`,
				src: 'Logo.svg',
				width: 120,
				height: 22
			}),
			r('div', null,
				GlobalDelayField(),
				BulkSelector(),
				CookieSelector(),
				ProxyFallbackField(),
				ResetButton(),
				SettingsMenuTrigger())))
}

function SettingsMenuTrigger() {
	const id = '_settings_menu_'
	return (
		r('button', {
				title: t`Settings`,
				popovertarget: id,
				className: CSS.MenuTrigger
			},
			SettingsIcon(),
			Defer(() => SettingsMenu(id))))
}

function SettingsMenu(id) {
	const { groupByMethod, toggleGroupByMethod } = state
	return (
		r('menu', {
				id,
				popover: '',
				className: CSS.SettingsMenu
			},

			r('label', className(CSS.GroupByMethod),
				r('input', {
					type: 'checkbox',
					checked: groupByMethod,
					autofocus: true,
					onChange: toggleGroupByMethod
				}),
				r('span', null, t`Group by Method`)),

			r('a', {
				href: 'https://github.com/ericfortis/mockaton',
				target: '_blank',
				rel: 'noopener noreferrer'
			}, t`Documentation`)))
}


function CookieSelector() {
	const { cookies } = state
	function onChange() {
		mockaton.selectCookie(this.value)
			.then(parseError)
			.catch(onError)
	}
	const disabled = cookies.length <= 1
	const list = cookies.length ? cookies : [[t`None`, true]]
	return (
		r('label', className(CSS.Field, CSS.CookieSelector),
			r('span', null, t`Cookie`),
			r('select', {
				autocomplete: 'off',
				disabled,
				title: disabled ? t`No cookies specified in config.cookies` : '',
				onChange
			}, list.map(([value, selected]) =>
				r('option', { value, selected }, value)))))
}

function BulkSelector() {
	const { comments } = state
	// UX wise this should be a menu instead of this `select`.
	// But this way is easier to implement, with a few hacks.
	const firstOption = t`Pick Commentâ€¦`
	function onChange() {
		const value = this.value
		this.value = firstOption // Hack 
		mockaton.bulkSelectByComment(value)
			.then(parseError)
			.then(updateState)
			.then(() => focus(`.${CSS.BulkSelector}`))
			.catch(onError)
	}
	const disabled = !comments.length
	return (
		r('label', className(CSS.Field),
			r('span', null, t`Bulk Select`),
			r('select', {
					className: CSS.BulkSelector,
					autocomplete: 'off',
					disabled,
					title: disabled ? t`No mock files have comments which are anything within parentheses on the filename.` : '',
					onChange
				},
				r('option', { value: firstOption }, firstOption),
				r('hr'),
				comments.map(value =>
					r('option', { value }, value)),
				r('hr'),
				r('option', { value: AUTOGENERATED_500_COMMENT }, t`Auto500`)
			)))
}

function GlobalDelayField() {
	const { delay } = state
	function onChange() {
		state.delay = this.valueAsNumber
		mockaton.setGlobalDelay(state.delay)
			.then(parseError)
			.catch(onError)
	}
	function onWheel(event) {
		if (event.deltaY > 0)
			this.stepUp()
		else
			this.stepDown()
		clearTimeout(onWheel.timer)
		onWheel.timer = setTimeout(onChange.bind(this), 300)
	}
	return (
		r('label', className(CSS.Field, CSS.GlobalDelayField),
			r('span', null, t`Delay (ms)`),
			r('input', {
				type: 'number',
				min: 0,
				step: 100,
				autocomplete: 'none',
				value: delay,
				onChange,
				onWheel: [onWheel, { passive: true }]
			})))
}

function ProxyFallbackField() {
	const { proxyFallback } = state
	const checkboxRef = useRef()
	function onChange() {
		checkboxRef.current.disabled = !this.validity.valid || !this.value.trim()

		if (!this.validity.valid)
			this.reportValidity()
		else
			mockaton.setProxyFallback(this.value.trim())
				.then(parseError)
				.then(updateState)
				.then(() => focus(`.${CSS.FallbackBackend} input`))
				.catch(onError)
	}
	return (
		r('div', className(CSS.Field, CSS.FallbackBackend),
			r('label', null,
				r('span', null, t`Fallback`),
				r('input', {
					type: 'url',
					autocomplete: 'none',
					placeholder: t`Type backend address`,
					value: proxyFallback,
					onChange
				})),
			SaveProxiedCheckbox(checkboxRef)))
}

function SaveProxiedCheckbox(ref) {
	const { collectProxied, canProxy } = state
	function onChange() {
		mockaton.setCollectProxied(this.checked)
			.then(parseError)
			.catch(onError)
	}
	return (
		r('label', className(CSS.SaveProxiedCheckbox),
			r('input', {
				ref,
				type: 'checkbox',
				disabled: !canProxy,
				checked: collectProxied,
				onChange
			}),
			r('span', null, t`Save Mocks`)))
}

function ResetButton() {
	function onClick() {
		mockaton.reset()
			.then(parseError)
			.then(updateState)
			.then(() => focus(`.${CSS.ResetButton}`))
			.catch(onError)
	}
	return (
		r('button', {
			className: CSS.ResetButton,
			onClick
		}, t`Reset`))
}



/** # MockList */

function MockList() {
	const { brokersByMethod, groupByMethod, canProxy } = state

	if (!Object.keys(brokersByMethod).length)
		return (
			r('div', className(CSS.empty),
				t`No mocks found`))

	if (groupByMethod)
		return Object.keys(brokersByMethod).map(method => Fragment(
			r('tr', null,
				r('th', { colspan: 2 + Number(canProxy) }),
				r('th', null, method)),
			rowsFor(method).map(Row)))

	return rowsFor('*').map(Row)
}


function Row({ method, urlMask, urlMaskDittoed, broker }) {
	const { canProxy, groupByMethod } = state
	return (
		r('tr', { 'data-method': method, 'data-urlMask': urlMask },
			canProxy && r('td', null, ProxyToggler(broker)),
			r('td', null, DelayRouteToggler(broker)),
			r('td', null, InternalServerErrorToggler(broker)),
			!groupByMethod && r('td', className(CSS.Method), method),
			r('td', null, PreviewLink(method, urlMask, urlMaskDittoed)),
			r('td', null, MockSelector(broker))))
}

function rowsFor(targetMethod) {
	const { brokersByMethod } = state

	const rows = []
	for (const [method, brokers] of Object.entries(brokersByMethod))
		if (targetMethod === '*' || targetMethod === method)
			for (const [urlMask, broker] of Object.entries(brokers))
				rows.push({ method, urlMask, broker })

	const sorted = rows.sort((a, b) => a.urlMask.localeCompare(b.urlMask))

	const urlMasksDittoed = dittoSplitPaths(sorted.map(r => r.urlMask))
	return sorted.map((r, i) => ({
		...r,
		urlMaskDittoed: urlMasksDittoed[i]
	}))
}

function PreviewLink(method, urlMask, urlMaskDittoed) {
	async function onClick(event) {
		event.preventDefault()
		try {
			document.querySelector(`.${CSS.PreviewLink}.${CSS.chosen}`)?.classList.remove(CSS.chosen)
			this.classList.add(CSS.chosen)
			await previewMock(method, urlMask, this.href)
		}
		catch (error) {
			onError(error)
		}
	}
	const [ditto, tail] = urlMaskDittoed
	return (
		r('a', {
			className: CSS.PreviewLink,
			href: urlMask,
			onClick
		}, ditto
			? [r('span', className(CSS.dittoDir), ditto), tail]
			: tail))
}

const STR_PROXIED = t`Proxied`

/** @param {ClientMockBroker} broker */
function MockSelector(broker) {
	function onChange() {
		const { urlMask, method } = parseFilename(this.value)
		mockaton.select(this.value)
			.then(parseError)
			.then(updateState)
			.then(() => linkFor(method, urlMask)?.click())
			.catch(onError)
	}

	let selected = broker.currentMock.file
	const { status } = parseFilename(selected)
	const files = broker.mocks.filter(item =>
		status === 500 ||
		!item.includes(AUTOGENERATED_500_COMMENT))
	if (!selected) {
		selected = STR_PROXIED
		files.push(selected)
	}

	function nameFor(file) {
		if (file === STR_PROXIED)
			return STR_PROXIED
		const { status, ext } = parseFilename(file)
		const comments = extractComments(file)
		const isAutogen500 = comments.includes(AUTOGENERATED_500_COMMENT)
		return [
			isAutogen500 ? '' : status,
			ext === 'empty' || ext === 'unknown' ? '' : ext,
			isAutogen500 ? t`Auto500` : comments.join(' ')
		].filter(Boolean).join(' ')
	}

	return (
		r('select', {
			onChange,
			autocomplete: 'off',
			'aria-label': t`Mock Selector`,
			disabled: files.length <= 1,
			...className(
				CSS.MockSelector,
				selected !== files[0] && CSS.nonDefault,
				status >= 400 && status < 500 && CSS.status4xx)
		}, files.map(file => (
			r('option', {
				value: file,
				selected: file === selected
			}, nameFor(file))))))
}

/** @param {ClientMockBroker} broker */
function DelayRouteToggler(broker) {
	function commit(checked) {
		const { method, urlMask } = parseFilename(broker.mocks[0])
		mockaton.setRouteIsDelayed(method, urlMask, checked)
			.then(parseError)
			.catch(onError)
	}
	return ClickDragToggler({
		checked: broker.currentMock.delayed,
		commit
	})
}


/** @param {ClientMockBroker} broker */
function InternalServerErrorToggler(broker) {
	function onChange() {
		const { method, urlMask } = parseFilename(broker.mocks[0])
		mockaton.toggle500(method, urlMask)
			.then(parseError)
			.then(updateState)
			.then(() => linkFor(method, urlMask)?.click())
			.catch(onError)
	}
	return (
		r('label', {
				className: CSS.InternalServerErrorToggler,
				title: t`Internal Server Error`
			},
			r('input', {
				type: 'checkbox',
				name: broker.currentMock.file,
				checked: parseFilename(broker.currentMock.file).status === 500,
				onChange
			}),
			r('span', null, t`500`)))
}

/** @param {ClientMockBroker} broker */
function ProxyToggler(broker) {
	function onChange() {
		const { urlMask, method } = parseFilename(broker.mocks[0])
		mockaton.setRouteIsProxied(method, urlMask, this.checked)
			.then(parseError)
			.then(updateState)
			.then(() => linkFor(method, urlMask)?.click())
			.catch(onError)
	}
	return (
		r('label', {
				className: CSS.ProxyToggler,
				title: t`Proxy Toggler`
			},
			r('input', {
				type: 'checkbox',
				checked: !broker.currentMock.file,
				onChange
			}),
			CloudIcon()))
}



/** # StaticFilesList */

function StaticFilesList() {
	const { staticBrokers, canProxy, groupByMethod } = state
	if (!Object.keys(staticBrokers).length)
		return null
	const dp = dittoSplitPaths(Object.keys(staticBrokers)).map(([ditto, tail]) => ditto
		? [r('span', className(CSS.dittoDir), ditto), tail]
		: tail)
	return (
		Fragment(
			r('tr', null,
				r('th', { colspan: (2 + Number(!groupByMethod)) + Number(canProxy) }),
				r('th', null, t`Static GET`)),
			Object.values(staticBrokers).map((broker, i) =>
				r('tr', null,
					canProxy && r('td'),
					r('td', null, DelayStaticRouteToggler(broker)),
					r('td', null, NotFoundToggler(broker)),
					!groupByMethod && r('td', className(CSS.Method), 'GET'),
					r('td', null, r('a', {
						href: broker.route,
						target: '_blank',
						className: CSS.PreviewLink
					}, dp[i]))
				))))
}

/** @param {ClientStaticBroker} broker */
function DelayStaticRouteToggler(broker) {
	function commit(checked) {
		mockaton.setStaticRouteIsDelayed(broker.route, checked)
			.then(parseError)
			.catch(onError)
	}
	return ClickDragToggler({
		checked: broker.delayed,
		commit
	})
}

/** @param {ClientStaticBroker} broker */
function NotFoundToggler(broker) {
	function onChange() {
		mockaton.setStaticRouteStatus(broker.route, this.checked ? 404 : 200)
			.then(parseError)
			.catch(onError)
	}
	return (
		r('label', {
				className: CSS.NotFoundToggler,
				title: t`Not Found`
			},
			r('input', {
				type: 'checkbox',
				checked: broker.status === 404,
				onChange
			}),
			r('span', null, t`404`)))
}


function ClickDragToggler({ checked, commit }) {
	function onPointerEnter(event) {
		if (event.buttons === 1)
			onPointerDown.call(this)
	}
	function onPointerDown() {
		this.checked = !this.checked
		commit(this.checked)
	}
	function onClick(event) {
		if (event.pointerType === 'mouse')
			event.preventDefault()
	}
	function onChange() {
		commit(this.checked)
	}
	return (
		r('label', {
				className: CSS.DelayToggler,
				title: t`Delay`
			},
			r('input', {
				type: 'checkbox',
				checked,
				onPointerEnter,
				onPointerDown,
				onClick,
				onChange
			}),
			TimerIcon()))
}



function Resizer() {
	return (
		r('div', {
			className: CSS.Resizer,
			onPointerDown: Resizer.onPointerDown
		}))
}
Resizer.raf = 0
Resizer.initialX = 0
Resizer.panelWidth = 0
Resizer.onPointerDown = function (event) {
	Resizer.initialX = event.clientX
	Resizer.panelWidth = leftSideRef.current.clientWidth
	addEventListener('pointerup', Resizer.onUp, { once: true })
	addEventListener('pointermove', Resizer.onMove)
	document.body.style.userSelect = 'none'
	document.body.style.cursor = 'col-resize'
}
Resizer.onMove = function (event) {
	const MIN_LEFT_WIDTH = 380
	Resizer.raf = Resizer.raf || requestAnimationFrame(() => {
		state.leftSideWidth = Math.max(Resizer.panelWidth - (Resizer.initialX - event.clientX), MIN_LEFT_WIDTH)
		leftSideRef.current.style.width = state.leftSideWidth + 'px'
		Resizer.raf = 0
	})
}
Resizer.onUp = function () {
	removeEventListener('pointermove', Resizer.onMove)
	cancelAnimationFrame(Resizer.raf)
	Resizer.raf = 0
	document.body.style.userSelect = 'auto'
	document.body.style.cursor = 'auto'
}


/** # Payload Preview */

const payloadViewerTitleRef = useRef()
const payloadViewerRef = useRef()
const SPINNER_DELAY = 80

function PayloadViewer() {
	return (
		r('div', className(CSS.PayloadViewer),
			r('h2', { ref: payloadViewerTitleRef }, t`Preview`),
			r('pre', null,
				r('code', { ref: payloadViewerRef }, t`Click a link to preview it`))))
}

function PayloadViewerProgressBar() {
	return (
		r('div', className(CSS.ProgressBar),
			r('div', { style: { animationDuration: state.delay - SPINNER_DELAY + 'ms' } })))
}

function PayloadViewerTitle({ file, statusText }) {
	const tokens = file.split('.')
	const ext = tokens.pop()
	const status = tokens.pop()
	const urlAndMethod = tokens.join('.') + '.'
	return (
		r('span', null,
			urlAndMethod,
			r('abbr', { title: statusText }, status),
			'.' + ext))
}

function PayloadViewerTitleWhenProxied({ mime, status, statusText, gatewayIsBad }) {
	return (
		r('span', null,
			gatewayIsBad
				? r('span', className(CSS.red), t`â›” Fallback Backend Error` + ' ')
				: r('span', null, t`Got` + ' '),
			r('abbr', { title: statusText }, status),
			' ' + mime))
}

async function previewMock(method, urlMask, href) {
	previewMock.controller?.abort()
	previewMock.controller = new AbortController

	const spinnerTimer = setTimeout(() => {
		payloadViewerTitleRef.current.replaceChildren(t`Fetchingâ€¦`)
		payloadViewerRef.current.replaceChildren(PayloadViewerProgressBar())
	}, SPINNER_DELAY)

	try {
		const response = await fetch(href, {
			method,
			signal: previewMock.controller.signal
		})
		clearTimeout(spinnerTimer)
		await updatePayloadViewer(method, urlMask, response)
	}
	catch (err) {
		onError(err)
		payloadViewerRef.current.replaceChildren()
	}
}


async function updatePayloadViewer(method, urlMask, response) {
	const mime = response.headers.get('content-type') || ''

	const file = mockSelectorFor(method, urlMask).value
	if (file === STR_PROXIED)
		payloadViewerTitleRef.current.replaceChildren(PayloadViewerTitleWhenProxied({
			status: response.status,
			statusText: response.statusText,
			mime,
			gatewayIsBad: response.headers.get(HEADER_FOR_502)
		}))
	else
		payloadViewerTitleRef.current.replaceChildren(PayloadViewerTitle({
			statusText: response.statusText,
			file
		}))

	if (mime.startsWith('image/')) { // Naively assumes GET.200
		payloadViewerRef.current.replaceChildren(
			r('img', {
				src: URL.createObjectURL(await response.blob())
			}))
	}
	else {
		const body = await response.text() || t`/* Empty Response Body */`
		if (mime === 'application/json')
			payloadViewerRef.current.replaceChildren(r('span', className(CSS.json), syntaxJSON(body)))
		else if (isXML(mime))
			payloadViewerRef.current.replaceChildren(syntaxXML(body))
		else
			payloadViewerRef.current.textContent = body
	}
}

function isXML(mime) {
	return ['text/html', 'text/xml', 'application/xml'].includes(mime)
		|| /application\/.*\+xml/.test(mime)
}


function trFor(method, urlMask) {
	return document.querySelector(`tr[data-method="${method}"][data-urlMask="${urlMask}"]`)
}
function linkFor(method, urlMask) {
	return trFor(method, urlMask)?.querySelector(`a.${CSS.PreviewLink}`)
}
function mockSelectorFor(method, urlMask) {
	return trFor(method, urlMask)?.querySelector(`select.${CSS.MockSelector}`)
}

function focus(selector) {
	document.querySelector(selector)?.focus()
}

/** # Misc */

async function parseError(response) {
	if (response.ok)
		return
	if (response.status === 422)
		throw await response.text()
	throw response.statusText
}

function onError(error) {
	if (error?.name === 'AbortError')
		return
	if (error?.message === 'Failed to fetch')
		showErrorToast(t`Looks like the Mockaton server is not running`)
	else
		showErrorToast(error || t`Unexpected Error`)
	console.error(error)
}

function showErrorToast(msg) {
	document.getElementsByClassName(CSS.ErrorToast)[0]?.remove()
	document.body.appendChild(
		r('div', {
			className: CSS.ErrorToast,
			onClick() {
				const toast = this
				document.startViewTransition(() => toast.remove())
			}
		}, msg))
}

function TimerIcon() {
	return (
		s('svg', { viewBox: '0 0 24 24' },
			s('path', { d: 'm11 5.6 0.14 7.2 6 3.7' })))
}

function CloudIcon() {
	return (
		s('svg', { viewBox: '0 0 24 24' },
			s('path', { d: 'm6.1 8.9c0.98-2.3 3.3-3.9 6-3.9 3.3-2e-7 6 2.5 6.4 5.7 0.018 0.15 0.024 0.18 0.026 0.23 0.0016 0.037 8.2e-4 0.084 0.098 0.14 0.097 0.054 0.29 0.05 0.48 0.05 2.2 0 4 1.8 4 4s-1.8 4-4 4c-4-0.038-9-0.038-13-0.018-2.8 0-5-2.2-5-5-2.2e-7 -2.8 2.2-5 5-5 2.8 2e-7 5 2.2 5 5' }),
			s('path', { d: 'm6.1 9.1c2.8 0 5 2.3 5 5' })))
}

function SettingsIcon() {
	return (
		s('svg', { viewBox: '0 0 24 24' },
			s('path', { d: 'M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6' })))
}

/**
 * # Poll UI Sync Version
 * The version increments when a mock file is added or removed
 */

function initLongPoll() {
	poll.oldSyncVersion = 0
	poll.controller = new AbortController()
	poll()
	document.addEventListener('visibilitychange', () => {
		if (document.hidden) {
			poll.controller.abort('_hidden_tab_')
			poll.controller = new AbortController()
		}
		else
			poll()
	})
}

async function poll() {
	try {
		const response = await mockaton.getSyncVersion(poll.oldSyncVersion, poll.controller.signal)
		if (response.ok) {
			const syncVersion = await response.json()
			if (poll.oldSyncVersion !== syncVersion) { // because it could be < or >
				poll.oldSyncVersion = syncVersion
				await updateState()
			}
			poll()
		}
		else
			throw response.status
	}
	catch (error) {
		if (error !== '_hidden_tab_')
			setTimeout(poll, 3000)
	}
}


/** # Utils */

function className(...args) {
	return {
		className: args.filter(Boolean).join(' ')
	}
}


function createElement(tag, props, ...children) {
	const node = document.createElement(tag)
	for (const [k, v] of Object.entries(props || {}))
		if (k === 'ref') v.current = node
		else if (k === 'style') Object.assign(node.style, v)
		else if (k.startsWith('on')) node.addEventListener(k.slice(2).toLowerCase(), ...[v].flat())
		else if (k in node) node[k] = v
		else node.setAttribute(k, v)
	node.append(...children.flat().filter(Boolean))
	return node
}

function createSvgElement(tagName, props, ...children) {
	const elem = document.createElementNS('http://www.w3.org/2000/svg', tagName)
	for (const [k, v] of Object.entries(props))
		elem.setAttribute(k, v)
	elem.append(...children.flat().filter(Boolean))
	return elem
}

function useRef() {
	return { current: null }
}

function Fragment(...args) {
	const frag = new DocumentFragment()
	for (const arg of args)
		if (Array.isArray(arg))
			frag.append(...arg)
		else
			frag.appendChild(arg)
	return frag
}

function Defer(cb) {
	const placeholder = document.createComment('')
	deferred(() => placeholder.replaceWith(cb()))
	return placeholder
}

function deferred(cb) {
	return window.requestIdleCallback
		? requestIdleCallback(cb)
		: setTimeout(cb, 100) // Safari
}


// When false, the URL will be updated with param=false
function initPreference(param) {
	const qs = new URLSearchParams(location.search)
	if (!qs.has(param)) {
		const group = localStorage.getItem(param) !== 'false'
		if (!group) {
			const url = new URL(location.href)
			url.searchParams.set(param, false)
			history.replaceState(null, '', url)
		}
		return group
	}
	return qs.get(param) !== 'false'
}

// When false, the URL and localStorage will have param=false
function togglePreference(param, nextVal) {
	if (nextVal)
		localStorage.removeItem(param)
	else
		localStorage.setItem(param, nextVal)

	const url = new URL(location.href)
	if (nextVal)
		url.searchParams.delete(param)
	else
		url.searchParams.set(param, false)
	history.replaceState(null, '', url)
}


/**
 * Think of this as a way of printing a directory tree in which
 * the repeated folder paths are kept but styled differently.
 * @param {string[]} paths - sorted
 */
function dittoSplitPaths(paths) {
	const result = [['', paths[0]]]
	const pathsInParts = paths.map(p => p.split('/').filter(Boolean))

	for (let i = 1; i < paths.length; i++) {
		const prevParts = pathsInParts[i - 1]
		const currParts = pathsInParts[i]

		let j = 0
		while (
			j < currParts.length &&
			j < prevParts.length &&
			currParts[j] === prevParts[j])
			j++

		if (!j) // no common dirs
			result.push(['', paths[i]])
		else {
			const ditto = '/' + currParts.slice(0, j).join('/') + '/'
			result.push([ditto, paths[i].slice(ditto.length)])
		}
	}
	return result
}

dittoSplitPaths.test = function () {
	const input = [
		'/api/user',
		'/api/user/avatar',
		'/api/user/friends',
		'/api/vid',
		'/api/video/id',
		'/api/video/stats',
		'/v2/foo',
		'/v2/foo/bar'
	]
	const expected = [
		['', '/api/user'],
		['/api/user/', 'avatar'],
		['/api/user/', 'friends'],
		['/api/', 'vid'],
		['/api/', 'video/id'],
		['/api/video/', 'stats'],
		['', '/v2/foo'],
		['/v2/foo/', 'bar']
	]
	console.assert(JSON.stringify(dittoSplitPaths(input)) === JSON.stringify(expected))
}



function syntaxJSON(json) {
	const MAX_NODES = 50_000
	let nNodes = 0
	const frag = new DocumentFragment()

	function span(className, textContent) {
		nNodes++
		const s = document.createElement('span')
		s.className = className
		s.textContent = textContent
		frag.appendChild(s)
	}

	function text(t) {
		nNodes++
		frag.appendChild(document.createTextNode(t))
	}

	let match
	let lastIndex = 0
	syntaxJSON.regex.lastIndex = 0 // resets regex
	while ((match = syntaxJSON.regex.exec(json)) !== null) {
		if (nNodes > MAX_NODES)
			break

		if (match.index > lastIndex)
			text(json.slice(lastIndex, match.index))

		const [full, str, colon, punc] = match
		lastIndex = match.index + full.length

		if (str && colon) {
			span(CSS.syntaxKey, str)
			text(colon)
		}
		else if (punc) text(punc)
		else if (str) span(CSS.syntaxStr, str)
		else span(CSS.syntaxVal, full)
	}
	frag.normalize()
	text(json.slice(lastIndex))
	return frag
}
syntaxJSON.regex = /("(?:\\u[a-fA-F0-9]{4}|\\[^u]|[^\\"])*")(\s*:)?|([{}\[\],:\s]+)|\S+/g
// Capture group order: [string, optional colon, punc]



function syntaxXML(xml) {
	const MAX_NODES = 50_000
	let nNodes = 0
	const frag = new DocumentFragment()

	function span(className, textContent) {
		nNodes++
		const s = document.createElement('span')
		s.className = className
		s.textContent = textContent
		frag.appendChild(s)
	}

	function text(t) {
		nNodes++
		frag.appendChild(document.createTextNode(t))
	}

	let match
	let lastIndex = 0
	syntaxXML.regex.lastIndex = 0
	while ((match = syntaxXML.regex.exec(xml)) !== null) {
		if (nNodes > MAX_NODES)
			break

		if (match.index > lastIndex)
			text(xml.slice(lastIndex, match.index))

		lastIndex = match.index + match[0].length

		if (match[1]) span(CSS.syntaxPunc, match[1])
		else if (match[2]) span(CSS.syntaxTag, match[2])
		else if (match[3]) span(CSS.syntaxAttr, match[3])
		else if (match[4]) span(CSS.syntaxAttrVal, match[4])
	}
	text(xml.slice(lastIndex))
	frag.normalize()
	return frag
}
syntaxXML.regex = /(<\/?|\/?>|\?>)|(?<=<\??\/?)([A-Za-z_:][\w:.-]*)|([A-Za-z_:][\w:.-]*)(?==)|("(?:[^"\\]|\\.)*")/g
// Capture groups order:  [tagPunc, tagName, attrName, attrVal]

