import { tmpdir } from 'node:os'
import { promisify } from 'node:util'
import { createServer } from 'node:http'
import { dirname, join } from 'node:path'
import { randomUUID } from 'node:crypto'
import { equal, deepEqual, match } from 'node:assert/strict'
import { describe, it, before, beforeEach, after } from 'node:test'
import { writeFileSync, mkdtempSync, mkdirSync, unlinkSync, readFileSync } from 'node:fs'

import { logger } from './utils/logger.js'
import { mimeFor } from './utils/mime.js'
import { Mockaton } from './Mockaton.js'
import { readBody } from './utils/http-request.js'
import { Commander } from './ApiCommander.js'
import { CorsHeader } from './utils/http-cors.js'
import { parseFilename } from './Filename.js'
import { listFilesRecursively } from './utils/fs.js'
import { API, DEFAULT_500_COMMENT, DEFAULT_MOCK_COMMENT } from './ApiConstants.js'


const mocksDir = mkdtempSync(tmpdir() + '/mocks') + '/'
const staticDir = mkdtempSync(tmpdir() + '/static') + '/'

const fixtureGetSimple = [
	'/api/basic',
	'api/basic.GET.200.json',
	'Simple JSON'
]
const fixtureCustomMime = [
	'/api/custom-mime',
	'api/custom-mime.GET.200.my_custom_extension',
	'Custom Extension and MIME'
]
const fixtureNonDefaultInName = [
	'/api/the-route',
	'api/the-route.GET.200.json',
	'default my route body content'
]
const fixtureDefaultInName = [
	'/api/the-route',
	'api/the-route(default).GET.200.json',
	'default my route body content'
]
const fixtureDelayed = [
	'/api/delayed',
	'api/delayed.GET.200.json',
	'Route_To_Be_Delayed'
]

/* Only fixtures with PUT */
const fixtureForRegisteringPutA = [
	'/api/register',
	'api/register(a).PUT.200.json',
	'fixture_for_registering_a'
]
const fixtureForRegisteringPutB = [
	'/api/register',
	'api/register(b).PUT.200.json',
	'fixture_for_registering_b'
]
const fixtureForRegisteringPutA500 = [
	'/api/register',
	'api/register.PUT.500.json',
	'fixture_for_registering_500'
]
const fixtureForUnregisteringPutC = [
	'/api/unregister',
	'api/unregister.PUT.200.json',
	'fixture_for_unregistering'
]


const fixtures = [
	[
		'/api',
		'api/.GET.200.json',
		'index-like route for /api, which could just be the extension convention'
	],

	// Exact route paths
	fixtureGetSimple,
	fixtureDefaultInName,
	fixtureDelayed,
	[
		'/api/the-route',
		'api/the-route(default).GET.200.json',
		'default my route body content'
	],
	[
		'/api/the-mime',
		'api/the-mime.GET.200.txt',
		'determines the content type'
	], [
		'/api/the-method-and-status',
		'api/the-method-and-status.POST.201.json',
		'obeys the HTTP method and response status'
	], [
		'/api/the-comment',
		'api/the-comment(this is the actual comment).GET.200(another comment).txt',
		''
	], [
		'/api/alternative',
		'api/alternative(comment-1).GET.200.json',
		'With_Comment_1'
	], [
		'/api/dot.in.path',
		'api/dot.in.path.GET.200.json',
		'Dot_in_Path'
	], [
		'/api/space & colon:',
		'api/space & colon:.GET.200.json',
		'Decodes URI'
	],

	[
		'/api/uncommon-method',
		'/api/uncommon-method.ACL.200.json',
		'node.js doesn’t support arbitrary HTTP methods, but it does support a few non-standard ones'
	],


	// Dynamic Params
	[
		'/api/user/1234',
		'api/user/[id]/.GET.200.json',
		'variable at end'
	], [
		'/api/user/1234/suffix',
		'api/user/[id]/suffix.GET.200.json',
		'sandwich a variable that another route has at the end'
	], [
		'/api/user/exact-route',
		'api/user/exact-route.GET.200.json',
		'ensure dynamic params do not take precedence over exact routes'
	],

	// Query String
	// TODO ignore on Windows (because of ?)
	[
		'/api/my-query-string?foo=[foo]&bar=[bar]',
		'api/my-query-string?foo=[foo]&bar=[bar].GET.200.json',
		'two query string params'
	], [
		'/api/company-a',
		'api/company-a/[id]?limit=[limit].GET.200.json',
		'without pretty-param nor query-params'
	], [
		'/api/company-b/',
		'api/company-b/[id]?limit=[limit].GET.200.json',
		'without pretty-param nor query-params with trailing slash'
	], [
		'/api/company-c/1234',
		'api/company-c/[id]?limit=[limit].GET.200.json',
		'with pretty-param and without query-params'
	], [
		'/api/company-d/1234/?',
		'api/company-d/[id]?limit=[limit].GET.200.json',
		'with pretty-param and without query-params, but with trailing slash and "?"'
	], [
		'/api/company-e/1234/?limit=4',
		'api/company-e/[id]?limit=[limit].GET.200.json',
		'with pretty-param and query-params'
	],
	fixtureCustomMime
]
for (const [, file, body] of [fixtureNonDefaultInName, ...fixtures])
	write(file, file.endsWith('.json') ? JSON.stringify(body) : body)

write('api/.GET.500.txt', 'keeps non-autogenerated 500')
write('api/alternative(comment-2).GET.200.json', JSON.stringify({ comment: 2 }))
write('api/my-route(comment-2).GET.200.json', JSON.stringify({ comment: 2 }))
write('api/ignored.GET.200.json~', '')

// JavaScript to JSON (params for testing URL decoding)
write('/api/object?param=[param].GET.200.js', 'export default { JSON_FROM_JS: true }')

const fixtureStaticIndex = ['index.html', '<h1>Static</h1>']
const staticFiles = [
	fixtureStaticIndex,
	['assets/app.js', 'const app = 1'],
	['another-entry/index.html', '<h1>Another</h1>']
]
const fixtureStaticAddAtRuntime = ['runtime.html', '<h1>Runtime</h1>']
writeStatic('ignored.js~', 'ignored_file_body')
for (const [file, body] of staticFiles)
	writeStatic(file, body)


const server = await Mockaton({
	mocksDir,
	staticDir,
	onReady: () => {},
	cookies: {
		userA: 'CookieA',
		userB: 'CookieB'
	},
	extraHeaders: ['Server', 'MockatonTester'],
	extraMimes: {
		my_custom_extension: 'my_custom_mime'
	},
	corsOrigins: ['http://example.com'],
	corsExposedHeaders: ['Content-Encoding']
})

function mockatonAddr() {
	const { address, port } = server.address()
	return `http://${address}:${port}`
}

function request(path, options = {}) {
	return fetch(`${mockatonAddr()}${path}`, options)
}

const commander = new Commander(mockatonAddr())

/** @returns {State} */
async function fetchState() {
	return await (await commander.getState()).json()
}


beforeEach(async () => {
	await commander.reset()
})

// TODO this a Windows test. And it should not use the function but read the getState payload
it('normalizes backslashes with forward ones', () => {
	const files = listFilesRecursively(mocksDir)
	equal(files[0], 'api/.GET.200.json')
})

it('Dashboard renders', async () => {
	const res = await request(API.dashboard)
	match(await res.text(), new RegExp('<!DOCTYPE html>'))
})

describe('404', () => {
	it('when there’s no mock', async () =>
		equal((await request('/api/non-existing')).status, 404))

	it('when there’s no mock at all for a method', async () =>
		equal((await request('/api/non-existing-too', { method: 'DELETE' })).status, 404))

	it('ignores files ending in ~ by default, e.g. JetBrains temp files', async () =>
		equal((await request('/api/ignored')).status, 404))

	it('ignores static files ending in ~ by default, e.g. JetBrains temp files', async () =>
		equal((await request('/ignored.js~')).status, 404))
})

it('returns 500 when a handler throws', async t => {
	const spy = t.mock.method(logger, 'error')
	equal((await request(API.throws)).status, 500)
	equal(spy.mock.calls[0].arguments[0], 'Test500')
})

for (const [url, file, body] of fixtures)
	testMockDispatching(url, file, body)

describe('default mock', () => {
	testMockDispatching(...fixtureDefaultInName)
	it('sorts mocks list with the user specified default first for dashboard display', async () => {
		const { mocks } = (await fetchState()).brokersByMethod.GET[fixtureDefaultInName[0]]
		equal(mocks[0], fixtureDefaultInName[1])
		equal(mocks[1], fixtureNonDefaultInName[1])
	})
})

describe('Set Global Delay', () => {
	it('422 for invalid global delay value', async () => {
		const res = await commander.setGlobalDelay('not-a-number')
		equal(res.status, 422)
		equal(await res.text(), 'Expected non-negative integer for "delay"')
	})

	it('200 for valid global delay value', async () => {
		const res = await commander.setGlobalDelay(150)
		equal(res.status, 200)
		equal((await fetchState()).delay, 150)
	})
})

it('updates route delay', async () => {
	const delay = 80
	const [url, file, expectedBody] = fixtureDelayed
	const { method } = parseFilename(file)
	await commander.setGlobalDelay(delay)
	await commander.setRouteIsDelayed(method, url, true)
	const now = new Date()
	const res = await request(url)
	equal(await res.text(), JSON.stringify(expectedBody))
	equal((new Date()).getTime() - now.getTime() > delay, true)
})

it('422 when updating non-existing mock alternative. There are mocks for /api/the-route but not for this one', async () => {
	const missingFile = 'api/the-route(non-existing-variant).GET.200.json'
	const res = await commander.select(missingFile)
	equal(res.status, 422)
	equal(await res.text(), `Missing Mock: ${missingFile}`)
})

it('autogenerated in-memory 500', async () => {
	await commander.select(`api/alternative${DEFAULT_500_COMMENT}.GET.500.empty`)
	const res = await request('/api/alternative')
	equal(res.status, 500)
	equal(await res.text(), '')
	equal(res.headers.get('content-type'), '')
})

it('preserves existing 500', async () => {
	const url = '/api'
	const file = 'api/.GET.500.txt'
	const expectedBody = 'keeps non-autogenerated 500'
	await commander.select(file)
	const res = await request(url)
	equal(res.status, 500)
	equal(await res.text(), expectedBody)
})

it('updates current selected mock', async () => {
	const url = '/api/alternative'
	const file = 'api/alternative(comment-2).GET.200.json'
	const expectedBody = JSON.stringify({ comment: 2 })
	await commander.select(file)
	const res = await request(url)
	equal(res.status, 200)
	equal(await res.text(), expectedBody)
})

describe('comments', () => {
	it('Extracts all comments without duplicates', async () => {
		deepEqual((await fetchState()).comments, [
			'(comment-1)',
			'(comment-2)',
			DEFAULT_500_COMMENT,
			'(this is the actual comment)',
			'(another comment)',
			DEFAULT_MOCK_COMMENT
		])
	})

	describe('selects exact', async () => {
		beforeEach(async () => {
			await commander.bulkSelectByComment('(comment-2)')
		})
		const tests = [
			['/api/alternative', 'api/alternative(comment-2).GET.200.json', { comment: 2 }],
			['/api/my-route', 'api/my-route(comment-2).GET.200.json', { comment: 2 }]
		]
		for (const [url, file, body] of tests) {
			await it(`url: ${url}`, async () => {
				const { method } = parseFilename(file)
				const res = await request(url, { method })
				deepEqual(await res.json(), body)
			})
		}
	})

	describe('selects partial', async () => {
		beforeEach(async () => {
			await commander.bulkSelectByComment('(mment-1)')
		})
		const tests = [
			['/api/alternative', 'api/alternative(comment-1).GET.200.json', 'With_Comment_1']
		]
		for (const [url, file, body] of tests) {
			await it(`url: ${url}`, async () => {
				const { method } = parseFilename(file)
				const res = await request(url, { method })
				deepEqual(await res.json(), body)
			})
		}
	})
})


for (const [url, file, body] of fixtures)
	testMockDispatching(url, file, body)

testMockDispatching('/api/object', 'api/object.GET.200.js', { JSON_FROM_JS: true }, mimeFor('.json'))
testMockDispatching(...fixtureCustomMime, 'my_custom_mime')

it('JS Function Mocks', async () => {
	write('api/js-func.POST.200.js', `
export default function (req, response) {
  response.setHeader('content-type', 'custom-mime')
  return 'SOME_STRING'
}`)
	await sleep()
	testMockDispatching('/api/js-func',
		'api/js-func.POST.200.js',
		'SOME_STRING',
		'custom-mime')
})

describe('Cookie', () => {
	it('Defaults to the first key:value', async () => {
		deepEqual((await fetchState()).cookies, [
			['userA', true],
			['userB', false]
		])
	})

	it('Updates selected cookie', async () => {
		await commander.selectCookie('userB')
		deepEqual((await fetchState()).cookies, [
			['userA', false],
			['userB', true]
		])
	})

	it('422 when trying to select non-existing cookie', async () =>
		equal((await commander.selectCookie('non-existing-cookie-key')).status, 422))
})

describe('Static File Serving', () => {
	it('404 path traversal', async () =>
		equal((await request('/../../../../../../../../../../../%2E%2E/etc/passwd')).status, 404))

	it('Defaults to index.html', async () => {
		const res = await request('/')
		equal(res.status, 200)
		equal(await res.text(), '<h1>Static</h1>')
	})

	it('Defaults to in subdirs index.html', async () => {
		const res = await request('/another-entry')
		equal(res.status, 200)
		equal(await res.text(), '<h1>Another</h1>')
	})

	it('Serves exacts paths', async () => {
		const res = await request('/assets/app.js')
		equal(res.status, 200)
		equal(await res.text(), 'const app = 1')
	})
})

it('Static File List', async () => {
	const { staticBrokers } = await fetchState()
	deepEqual(Object.keys(staticBrokers).sort(), staticFiles.map(([file]) => '/' + file).sort())
})

it('Invalid filenames get skipped, so they don’t crash the server', async t => {
	const spy = t.mock.method(logger, 'warn')
	write('api/_INVALID_FILENAME_CONVENTION_.json', '')
	write('api/bad-filename-method._INVALID_METHOD_.200.json', '')
	write('api/bad-filename-status.GET._INVALID_STATUS_.json', '')
	await sleep()
	equal(spy.mock.calls[0].arguments[0], 'Invalid Filename Convention')
	equal(spy.mock.calls[1].arguments[0], 'Unrecognized HTTP Method: "_INVALID_METHOD_"')
	equal(spy.mock.calls[2].arguments[0], 'Invalid HTTP Response Status: "NaN"')
})

describe('Fallback', () => {
	let fallbackServer
	before(async () => {
		fallbackServer = createServer(async (req, response) => {
			response.writeHead(423, {
				'custom_header': 'my_custom_header',
				'content-type': mimeFor('.txt'),
				'set-cookie': [
					'cookieA=A',
					'cookieB=B'
				]
			})
			response.end(await readBody(req)) // echoes they req body payload
		})
		await promisify(fallbackServer.listen).bind(fallbackServer, 0, '127.0.0.1')()
		await commander.setProxyFallback(`http://localhost:${fallbackServer.address().port}`)
		await commander.setCollectProxied(true)
	})

	after(() => fallbackServer.close())

	it('Relays to fallback server and saves the mock', async () => {
		const reqBodyPayload = 'text_req_body'

		const res = await request(`/api/non-existing-mock/${randomUUID()}`, {
			method: 'POST',
			body: reqBodyPayload
		})
		equal(res.status, 423)
		equal(res.headers.get('custom_header'), 'my_custom_header')
		equal(res.headers.get('set-cookie'), ['cookieA=A', 'cookieB=B'].join(', '))
		equal(await res.text(), reqBodyPayload)

		const savedBody = readFileSync(join(mocksDir, 'api/non-existing-mock/[id].POST.423.txt'), 'utf8')
		equal(savedBody, reqBodyPayload)
	})
})

describe('Set Proxy Fallback', () => {
	it('422 when value is not a valid URL', async () => {
		const res = await commander.setProxyFallback('bad url')
		equal(res.status, 422)
		equal(await res.text(), 'Invalid Proxy Fallback URL')
	})

	it('sets fallback', async () => {
		const res = await commander.setProxyFallback('http://example.com')
		equal(res.status, 200)
		equal((await fetchState()).proxyFallback, 'http://example.com')
	})

	it('unsets fallback', async () => {
		const res = await commander.setProxyFallback('')
		equal(res.status, 200)
		equal((await fetchState()).proxyFallback, '')
	})
})

describe('Set Collect Proxied', () => {
	it('422 for invalid collectProxied value', async () => {
		const res = await commander.setCollectProxied('not-a-boolean')
		equal(res.status, 422)
		equal(await res.text(), 'Expected a boolean for "collectProxied"')
	})

	it('200 set and unset', async () => {
		await commander.setCollectProxied(true)
		equal((await fetchState()).collectProxied, true)

		await commander.setCollectProxied(false)
		equal((await fetchState()).collectProxied, false)
	})
})

describe('CORS Allowed', () => {
	it('CORS preflight', async () => {
		await commander.setCorsAllowed(true)
		const res = await request('/does-not-matter', {
			method: 'OPTIONS',
			headers: {
				[CorsHeader.Origin]: 'http://example.com',
				[CorsHeader.AcRequestMethod]: 'GET'
			}
		})
		equal(res.status, 204)
		equal(res.headers.get(CorsHeader.AcAllowOrigin), 'http://example.com')
		equal(res.headers.get(CorsHeader.AcAllowMethods), 'GET')
	})

	it('CORS actual response', async () => {
		const res = await request(fixtureDefaultInName[0], {
			headers: {
				[CorsHeader.Origin]: 'http://example.com'
			}
		})
		equal(res.status, 200)
		equal(res.headers.get(CorsHeader.AcAllowOrigin), 'http://example.com')
		equal(res.headers.get(CorsHeader.AcExposeHeaders), 'Content-Encoding')
	})
})

describe('Registering', () => {
	const temp500 = `api/register${DEFAULT_500_COMMENT}.PUT.500.empty`

	it('registering new route creates temp 500 as well and re-registering is a noop', async () => {
		write(fixtureForRegisteringPutA[1], '')
		write(fixtureForRegisteringPutB[1], '')
		await sleep()
		write(fixtureForRegisteringPutA[1], '')
		await sleep()
		const { brokersByMethod } = await fetchState()
		deepEqual(brokersByMethod.PUT[fixtureForRegisteringPutA[0]].mocks, [
			fixtureForRegisteringPutA[1],
			fixtureForRegisteringPutB[1],
			temp500
		])
	})

	it('registering a 500 removes the temp 500 (and selects the new 500)', async () => {
		await commander.select(temp500)
		write(fixtureForRegisteringPutA500[1], '')
		await sleep()
		const { brokersByMethod } = await fetchState()
		const { mocks, currentMock } = brokersByMethod.PUT[fixtureForRegisteringPutA[0]]
		deepEqual(mocks, [
			fixtureForRegisteringPutA[1],
			fixtureForRegisteringPutB[1],
			fixtureForRegisteringPutA500[1]
		])
		deepEqual(currentMock, {
			file: fixtureForRegisteringPutA[1],
			delayed: false
		})
	})

	it('unregisters selected', async () => {
		await commander.select(fixtureForRegisteringPutA[1])
		remove(fixtureForRegisteringPutA[1])
		await sleep()
		const { brokersByMethod } = await fetchState()
		const { mocks, currentMock } = brokersByMethod.PUT[fixtureForRegisteringPutA[0]]
		deepEqual(mocks, [
			fixtureForRegisteringPutB[1],
			fixtureForRegisteringPutA500[1]
		])
		deepEqual(currentMock, {
			file: fixtureForRegisteringPutB[1],
			delayed: false
		})
	})

	it('unregistering the last mock removes broker', async () => {
		write(fixtureForUnregisteringPutC[1], '') // Register another PUT so it doesn't delete PUT from collection
		await sleep()
		remove(fixtureForUnregisteringPutC[1])
		await sleep()
		const { brokersByMethod } = await fetchState()
		equal(brokersByMethod.PUT[fixtureForUnregisteringPutC[0]], undefined)
	})

	it('unregistering the last PUT mock removes PUT from collection', async () => {
		remove(fixtureForRegisteringPutB[1])
		remove(fixtureForRegisteringPutA500[1])
		await sleep()
		const { brokersByMethod } = await fetchState()
		equal(brokersByMethod.PUT, undefined)
	})
})

describe('Set Route is Delayed', () => {
	const [route] = fixtureGetSimple
	it('422 for non-existing route', async () => {
		const res = await commander.setRouteIsDelayed('GET', route + '/non-existing', true)
		equal(res.status, 422)
		equal(await res.text(), `Route does not exist: GET ${route}/non-existing`)
	})

	it('422 for invalid delayed value', async () => {
		const res = await commander.setRouteIsDelayed('GET', route, 'not-a-boolean')
		equal(await res.text(), 'Expected boolean for "delayed"')
	})

	it('200', async () => {
		await commander.setRouteIsDelayed('GET', route, true)
		const { brokersByMethod } = await fetchState()
		equal(brokersByMethod.GET[route].currentMock.delayed, true)
	})
})

describe('Set Route is Proxied', () => {
	beforeEach(async () => await commander.setProxyFallback(''))
	after(async () => await commander.setProxyFallback(''))

	const [route, file] = fixtureGetSimple
	it('422 for non-existing route', async () => {
		const res = await commander.setRouteIsProxied('GET', route + '/non-existing', true)
		equal(res.status, 422)
		equal(await res.text(), `Route does not exist: GET ${route}/non-existing`)
	})

	it('422 for invalid proxied value', async () => {
		const res = await commander.setRouteIsProxied('GET', route, 'not-a-boolean')
		equal(res.status, 422)
		equal(await res.text(), 'Expected boolean for "proxied"')
	})

	it('422 for missing proxy fallback', async () => {
		const res = await commander.setRouteIsProxied('GET', route, true)
		equal(res.status, 422)
		equal(await res.text(), `There’s no proxy fallback`)
	})

	it('200 when setting', async () => {
		await commander.setProxyFallback('https://example.com')
		const res = await commander.setRouteIsProxied('GET', route, true)
		equal(res.status, 200)
		const { brokersByMethod } = await fetchState()
		equal(brokersByMethod.GET[route].currentMock.file, '')

		const res2 = await commander.setRouteIsProxied('GET', route, false)
		equal(res2.status, 200)
		const { brokersByMethod: b2 } = await fetchState()
		equal(b2.GET[route].currentMock.file, file) // default file
	})

	it('200 when unsetting', async () => {
		const res = await commander.setRouteIsProxied('GET', route, false)
		equal(res.status, 200)
		const { brokersByMethod } = await fetchState()
		equal(brokersByMethod.GET[route].currentMock.file, file) // default file
	})
})

describe('Set CORS allowed', () => {
	it('422 for non boolean', async () => {
		const res = await commander.setCorsAllowed('not-a-boolean')
		equal(res.status, 422)
		equal(await res.text(), 'Expected boolean for "corsAllowed"')
	})

	it('200', async () => {
		const res = await commander.setCorsAllowed(true)
		equal(res.status, 200)
		equal((await fetchState()).corsAllowed, true)

		await commander.setCorsAllowed(false)
		equal((await fetchState()).corsAllowed, false)
	})
})

describe('Set Static Route is Delayed', () => {
	const route = '/' + fixtureStaticIndex[0]
	it('422 for non-existing route', async () => {
		const res = await commander.setStaticRouteIsDelayed(route + '/non-existing', true)
		equal(res.status, 422)
		equal(await res.text(), `Static route does not exist: ${route}/non-existing`)
	})

	it('422 for invalid delayed value', async () => {
		const res = await commander.setStaticRouteIsDelayed(route, 'not-a-boolean')
		equal(await res.text(), 'Expected boolean for "delayed"')
	})

	it('200', async () => {
		await commander.setStaticRouteIsDelayed(route, true)
		const { staticBrokers } = await fetchState()
		equal(staticBrokers[route].delayed, true)
	})
})

describe('Set Static Route Status Code', () => {
	const route = '/' + fixtureStaticIndex[0]

	it('422 for non-existing route', async () => {
		const res = await commander.setStaticRouteStatus(route + '/non-existing', 200)
		equal(res.status, 422)
		equal(await res.text(), `Static route does not exist: ${route}/non-existing`)
	})

	it('422 for invalid delayed value', async () => {
		const res = await commander.setStaticRouteStatus(route, 'not-200-or-404')
		equal(res.status, 422)
		equal(await res.text(), 'Expected 200 or 404 status code')
	})

	it('200', async () => {
		const res = await commander.setStaticRouteStatus(route, 404)
		equal(res.status, 200)
		const { staticBrokers } = await fetchState()
		equal(staticBrokers[route].status, 404)
	})
})

describe('Resets Static Routes', () => {
	const route = '/' + fixtureStaticIndex[0]

	beforeEach(async () => {
		await commander.setStaticRouteIsDelayed(route, true)
		await commander.setStaticRouteStatus(route, 404)
		await commander.reset()
	})

	it('resets delayed', async () => {
		const { staticBrokers } = await fetchState()
		equal(staticBrokers[route].delayed, false)
	})

	it('resets status', async () => {
		const { staticBrokers } = await fetchState()
		equal(staticBrokers[route].status, 200)
	})
})

describe('static partial content', () => {
	const route = '/' + fixtureStaticIndex[0]
	const expectedBody = fixtureStaticIndex[1]

	it('206 serves partial content', async () => {
		const res1 = await request(route, { headers: { range: 'bytes=0-3' } })
		const res2 = await request(route, { headers: { range: 'bytes=4-' } })
		equal(res1.status, 206)
		equal(res2.status, 206)
		const body = await res1.text() + await res2.text()
		equal(body, expectedBody)
	})

	it('416 on invalid range (end > start)', async () => {
		const res = await request(route, { headers: { range: 'bytes=3-0' } })
		equal(res.status, 416)
	})
})

it('unregisters static route', async () => {
	const route = fixtureStaticIndex[0]
	removeStatic(route)
	await sleep()
	const { staticBrokers } = await fetchState()
	equal(staticBrokers['/' + route], undefined)
})

it('longPollSyncVersion responds immediately when version mismatches', async () => {
	const controller = new AbortController()
	const res1 = await commander.getSyncVersion(-1, controller.signal)
	equal(res1.status, 200)
	const version = await res1.json()

	const res2Prom = commander.getSyncVersion(version, controller.signal)
	writeStatic(...fixtureStaticAddAtRuntime)
	await sleep()
	const res2 = await res2Prom
	equal(res2.status, 200)
	equal(await res2.json(), version + 1)
})

it('body parser rejects invalid json in API requests', async t => {
	const spy = t.mock.method(logger, 'warn')
	equal((await request(API.cookies, {
		method: 'PATCH',
		body: '[invalid_json]'
	})).status, 422)
	equal(spy.mock.calls[0].arguments[0], 'BodyReaderError: Could not parse')
})

await it('head for get. returns the headers without body only for GETs requested as HEAD', async () => {
	const [route, , body] = fixtureGetSimple
	const res = await request(route, { method: 'HEAD' })
	equal(res.status, 200)
	equal(res.headers.get('content-length'), String(Buffer.byteLength(JSON.stringify(body))))
	equal(await res.text(), '')
})

server?.close()


function testMockDispatching(url, file, expectedBody, forcedMime = undefined) {
	it('URL Mask: ' + file, async () => {
		const { method, status } = parseFilename(file)
		const mime = forcedMime || mimeFor(file)
		const res = await request(url, { method })
		const body = mime === 'application/json'
			? await res.json()
			: await res.text()
		equal(res.status, status)
		equal(res.headers.get('content-type'), mime)
		equal(res.headers.get('set-cookie'), 'CookieA')
		equal(res.headers.get('server'), 'MockatonTester')
		deepEqual(body, expectedBody)
	})
}


/** # Utils */

function write(filename, data) { _write(mocksDir + filename, data) }
function remove(filename) { unlinkSync(mocksDir + filename) }

function writeStatic(filename, data) { _write(staticDir + filename, data) }
function removeStatic(filename) { unlinkSync(staticDir + filename) }

function _write(absPath, data) {
	mkdirSync(dirname(absPath), { recursive: true })
	writeFileSync(absPath, data, 'utf8')
}

async function sleep(ms = 50) {
	return new Promise(resolve => setTimeout(resolve, ms))
}
